%------------------------------------------------------------------------------%
%                            serialization library                             %
%------------------------------------------------------------------------------%

\section{Serialization library}

In this section, we will present the optimizations added to a serialization
library developed as a school project at ISIMA \cite{projectzz3isima}. The purpose
of these optimizations is to make this library usable in \gls{hpc} application.
In our context, the objective was to use this library to transfer datas between
nodes using MPI on the cluster version of \gls{hh}.

\subsection{The principle}

First, we are going to explain the principle of the library. We will not go to
deeply into the detail as the intrinsic mechanisms of the library have not changed
since the first version, which was already well described by
\cite{projectzz3isima}.\\

The basic purpose of the library has not changed. The objective is to be able to
make C++ classes serializable by writing as little code as possible, similarly
to what we could do with decorators in languages such as Java. The library
provides macros that need to be used in the serialized classes. These macros
generate the \texttt{serialize} and \texttt{deserialize} functions in the class.
We can see on the listing \ref{lst:serexamplebase}, how we can make
serializable, a class with two attributes. Here we use the macro
\texttt{SERIALIZABLE}, that generate the serialization functions, and the macro
\texttt{SERIALIZER} that initialize the \textit{serializer}.

%- begin listing ------------------------------------------------------------{{{
\begin{listing}[ht!]
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\normalsize,linenos]{C++}
  #include <serializer/serializable.hpp>

  class MyClass {
      SERIALIZABLE(int, double);
    public:
      MyClass(int x, double y): SERIALIZER(x_, y_), x_(x), y_(y) {}

    private:
      int x_ = 0;
      double y_ = 0;
  };
\end{minted}
\caption{Example of a class serialization}
\label{lst:serexamplebase}
\end{listing}
%- end listing --------------------------------------------------------------}}}

The \textit{serializer} is an attribute added to the class by the first macro.
It holds a data structure, the \texttt{MemberList} (previously called
\texttt{AttrContainer}), that will store references to the attributes of the
serialize class in order to be able to access their values or modify them. This
data structure acts as a list in which each node can store a different type. It
can also be compared to a \texttt{tuple}. In the generated serialization
function, we call the methods of the \textit{serializer} which will start the
serialization of the attributes in the member list.

To serialize the attribute, we use a special class called \texttt{Convertor}.
This class is composed of very generic template functions that are able to
convert most of the types of the standard library as well as some external types
if they match certain conditions. This means that the user of the library do not
need to make the translation of the serialized member by hand, everything is
done automatically in the convertor. Furthermore, it is possible to create its
own convertor class, either to add support for external types or to serialize
polymorphic objects (the library has to know which types it has to create during
the deserialization). The class has been changed since the first version of the
library. These changes will be explained in the section \ref{sec:convertor}.\\

Now that we have explained the basic principle of the library, we will detail
the optimizations and the features that have been added to it.

\subsection{Binary serialization}

The first version of the library was generating a human-readable string with a
format similar to JSON. For the new version, it has been decided to use the
binary format instead. The binary format is more interesting if we are searching
for performances since it takes less space and is very easy to parse. Moreover,
it allowed the removal of a lot of unnecessary information. For instance, to
generate the serialized string in the previous format, we needed to know the
identifiers of the member variables of the class. Now we assume that the data
will always be serialized and deserialized in the same order, so we do not need
this information anymore. Moreover, the previous format required to have
separators in the string to identify the beginning and the end of objects,
arrays, string (that had to be escaped manually\footnote{The string were
represented between \texttt{'\"'}, so we had to escape potential the double quote
character inside the string in order for them not to be considered as a
separator during the deserialization.}), \dots

To serialize fundamental types in binary, we use the \texttt{reinterpret\_cast}
to convert the address of the serialized variable in \texttt{char*} and
vice-versa. For the containers and strings, we start by writing the number of
elements (on a \texttt{size\_t}), then we write the elements themselves. When a
pointer is serialized, we start by adding a character (either \texttt{v} or
\texttt{n}) to specify if the pointer is null or valid. If the pointer is null,
there is nothing else to add. Otherwise, we deserialize the element on which the
pointer points to. During the deserialization, the pointers are dynamically
allocated if the variable is null, otherwise we just modify the pointed value.
This is important, especially for dynamic arrays since the dynamic allocation is
very slow. Pointers can lead to segmentation error or memory leak if they are
not handled properly. In our situation, we do not have any means to prevent such
behaviors, so we assume that the user of the library do things well or do not
use pointers.

\subsubsection{C-Struct}

It is possible, even in C++, to use \texttt{reinterpret\_cast} on
\gls{cstruct}. Doing so is very fast, so it has been tried to split the member
list in two parts, in order to extract the fundamental members and then generate
a \gls{cstruct}. Such a structure could have been serialized faster than the
member list since it would not have required the call to the functions of the
convertor. Unfortunately, this optimization added a lot of complexity and
splitting the member list had a cost at runtime. It has eventually been decided
to abandon this feature.

\subsection{Redesigning the convertor}
\label{sec:convertor}

% todo
Since most of the types are serialized automatically, it was required for the
user to have a way to manually add conversion functions for external types.
Indeed, the user does not always have the possibility to make classes
serializable. For instance, with the Qt framework, we do not have access to the
class \texttt{QString} and this class cannot be serialized by the functions of
the default convertor.

In the previous version of the library, all the convertor functions where
defined in the macro \texttt{CONVERTOR}. This macro had to be used at the end of
all convertor class. This was done because the custom conversion functions
needed to be defined before the default ones in order for the code to compile.
To understand why this could not be done using basic inheritance, we will
consider the following example: the user wants to serialize a class that holds a
vector of an \texttt{Unknown} type. This type is an external one and it is not
supported by default, so it requires implementing a custom convertor using
inheritance. Now, we are going to try to compile the code. Firstly, we want to
serialize a vector and the dedicated conversion function is in the mother class
of the custom convertor. Then, once we are in the function that converts the
vector, we want to find the function that will treat the element stored in the
vector. Here there is a problem because this function is defined in the
sub-class, and we do not have access to it from the mother one. One solution
would be to use virtual functions. However, it was not possible by that time
because all the conversion function where templates since \gls{sfinae} was used
to differentiate one function from another.

Having such a macro in the library was a real problem. Indeed, the first issue
is the difficulty of maintaining the code. As all the functions were defined in
the macro, the compiler errors were difficult to read, and it was not possible
to use the full power of an IDE (there are no error in macros). The second issue
is the fact that a lot of code was generated. In fact, if the user wanted to
create multiple convertor classes, there was a lot of code duplication. Finally,
the usage of such a macro from the user's point of view was very unintuitive.

To remove the \texttt{CONVERTOR} macro, a method similar to the behaviors of
\gls{hh} has been utilized \cite{bardakoff2021analysis}. We use the
\texttt{Convert} behavior, that is a template class with two virtual pure
functions, \texttt{serialize} and \texttt{deserialize} that should be overridden
in the user's convertor class. The fact that the class is template but not the
methods allows them to be virtual. The definition of this class is visible on
the listing \ref{lst:convert}.

%- begin listing ------------------------------------------------------------{{{
\begin{listing}[ht!]
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\normalsize,linenos]{C++}
template <typename T> struct Convert {
    virtual std::string &serialize(T const &, std::string &) const = 0;
    virtual T deserialize(std::string_view &, T &) = 0;
};
\end{minted}
\caption{Convert class}
\label{lst:Convert}
\end{listing}
%- end listing --------------------------------------------------------------}}}

The default convertor class holds non-static member functions
\texttt{serialize\_} and \texttt{deserialize\_} (an \texttt{\_} is used to avoid
conflicts with the functions from \texttt{Convert}). These methods are
templates, and they use concepts from C++20 to match the types. The usage of
concepts is very important in this case because they are more flexible than
\gls{sfinae}. In fact, they easily permit the definition of fallback functions
that will be called when a non-supported type is serialized. These fallback
methods use the functions from \texttt{Convert} as we can see on the listing
\ref{lst:fallbackserialize}.

%- begin listing ------------------------------------------------------------{{{
\begin{listing}[ht!]
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\normalsize,linenos]{C++}
  template <serializer::tools::concepts::NonSerializable T>
  std::string &serialize_(T const &elt, std::string str) const {
      if constexpr (tools::mtf::contains_v<T, AdditionalTypes...>) {
          // we need a static cast because of implicit constructors (ex:
          // pointer to shared_ptr)
          return static_cast<const Convert<T> *>(this)->serialize(elt, str);
      } else {
          throw serializer::exceptions::UnsupportedTypeError<T>();
      }
  }
\end{minted}
\caption{Fallback serialization method}
\label{lstd:fallbackserialize}
\end{listing}
%- end listing --------------------------------------------------------------}}}

The last important thing is the fact that the default convertor inherits from
multiple \texttt{Convert} classes (one per new type added). To achieve that, we
can see on the listing \ref{lst:convertor} that we use the fold expressions with
variadic templates.

%- begin listing ------------------------------------------------------------{{{
\begin{listing}[ht!]
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\normalsize,linenos]{C++}
template <typename... AdditionalTypes>
struct Convertor : Convert<AdditionalTypes>... { /* ... */ };
\end{minted}
\caption{Convertor class}
\label{lst:convertor}
\end{listing}
%- end listing --------------------------------------------------------------}}}

The new \texttt{Convertor} class is then easier to use than the old macro. It
is also easier to maintain since macros in C and C++ are not made to contain
such an amount of code. Lastly, with this version, there is less code
duplication which makes this library usable in a case where memory is limited
(embedded C++ applications for instance).

\subsection{New features}

In addition to the optimization, some new features have been implemented.
Firstly, the support for static and dynamic arrays have been added.

For the static arrays, a conversion function has been implemented. In order to
serialize arrays, we need to know their sizes. For this, we use
\texttt{std::extent\_v}. Here, \texttt{std::extent\_v<T[N]>} returns \texttt{N}.
However, this requires that the user specifies the size of the array (we cannot
accept \texttt{T[]}). The conversion function is recursive and uses
\texttt{std::remove\_extent\_t} to convert multidimensional arrays.

%todo: example

In order to be serialized, dynamic arrays need to be differentiated from the
standard pointers. Furthermore, we also need to access the size of the array,
however, this size might not be known at compile time. To solve these problems,
a wrapper type \texttt{DynamicArray} has been utilized. The definition of this
class is shown on the listing \ref{lst:dynamicarray}.

%- begin listing ------------------------------------------------------------{{{
\begin{listing}[ht!]
\begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\normalsize,linenos]{C++}
template <concepts::Pointer T, typename DT, typename... DTs>
struct DynamicArray {
    explicit DynamicArray(T &mem, DT dim, DTs... dims)
        : mem(mem), dimensions(dim, dims...) {}

    explicit DynamicArray(T &mem, std::tuple<DT, DTs...> dimensions)
        : mem(mem), dimensions(dimensions) {}

    T &mem;
    std::tuple<DT, DTs...> dimensions;
};
\end{minted}
\caption{\texttt{DynamicArray} class}
\label{lst:dynamicarray}
\end{listing}
%- end listing --------------------------------------------------------------}}}

The \texttt{DynamicArray} class stores a reference to the member variable
holding the array's pointer. We use a reference in case we have to change the
pointer (potential allocation or free on deserialization). The dimensions of the
array are stored in a tuple. Here we can see that the types of the dimensions
are configurable. This means that the user can pass references to member
variables holding the dimensions, or use values if the size is known at compile
time. The number of dimensions is not related to the dimensions of the pointer.
Here, the user can have a multidimensional array stored in a 1D pointer, and
specify all the dimensions to the \texttt{DynamicArray}. For instance, we can
have the following type: \texttt{DynamicArray<double*, size\_t\&, size\_t>}. In
this example, we have a 2D array (matrix) stored in a 1D pointer. The first
dimension of this matrix might be variable, so it is store in a member variable
given by reference to the \texttt{DynamicArray}. The second dimension is
constant, so it is passed by value.

%todo: example

Finally, now we can give functions to the serializer. These functions will be
executed during the serialization and the deserialization.

%todo: static and dynamic arrays
%todo: functions

\subsection{Conclusion}
